# 笔记

## 5.1 应用程序基础

- 应用程序相关问题：
  - 功能：程序的角色是什么？
  - 操作：程序执行怎么样的操作？
  - CPU模式：用户级还是内核级？
  - 配置。
  - 指标。
  - 日志。
  - 版本。
  - BUGs。
  - 社区。
  - 书。
  - 专家。

## 5.1.3 观测性

- 操作系统的最大性能提升在于消除不必要的工作。对于应用程序也是如此。

## 5.2 应用程序性能技术

- 提升程序性能的常用技术：选择I/O大小，缓存，缓冲区，轮询，并发和并行，非阻塞I/O核处理器绑定。
- I/O尺寸:
  - 执行I/O的开销包括初始化缓冲区，系统调用，上下文切换，分配内核元数据，检查进程的权限和限制，映射地址到设备，执行内核和驱动代码执行I/O，以及，在最后释放元数据和缓冲区。
  - 从效率上来说，每次I/O传输的数据越多，效率越高。
  - 更大的I/O尺寸也会带来负面影响，比如运行慢，浪费缓存。
- 缓冲区：
  - 为了提高写操作性能，数据在送入下一层级浅灰合并放在缓冲区，增加了I/O大小，提升了操作效率。
  - 取决于写操作类型，这样可能会增加延时。
- 非阻塞I/O:
  - 多路并发I/O：每一个阻塞的I/O都会消耗一个线程，线程频繁创建和销毁，代价大。
  - 频繁发生的短时I/O，频繁切换上下文会消耗CPU资源和增加延时。
- 处理器绑定：
  - 线程运行在同一CPU上，能提高应用程序内存本地性，减少内存I/O，提高整体性能。
  - CPU绑定如果与其他CPU的绑定冲突，会损害性能，如CPU上的设备中断映射，或其他租户绑定同一CPU。

## 5.3 编程语言

- 编程语言可能是编译的或是解释的，也有可能通过虚拟机执行。

## 5.4.1 线程状态分析

- 目的：分辨应用程序线程的时间用在了什么地方。
- 六种状态：
  - 执行：在CPU上。
  - 可运行：等待轮到上CPU。
  - 匿名换页：可运行，但是因等待匿名换页而受阻。
  - 睡眠：包括等待包括网络，块设备和数据/文本页换入在内的I/O。
  - 锁：等待获取同步锁。
  - 空闲：等待工作。

## 5.4.3 系统调用分析

- 系统调用的时间包括I/O，锁，以及其他系统调用类型。
- 断点跟踪：设置系统调用入口和返回的断点（strace）。
